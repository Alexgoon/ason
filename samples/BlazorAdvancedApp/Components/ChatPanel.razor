@inject AsonClient Client
@inject SessionState Session
@inject IJSRuntime JS
@using MudBlazor
@using Microsoft.Extensions.AI

<style>
    .chat-wrapper {
        height: 100%;
        display: flex;
        flex-direction: column;
    }

    .chat-header {
        padding: .55rem .75rem .4rem .75rem;
    }

    .chat-messages-host {
        flex: 1 1 auto;
        min-height: 0;
        display: flex;
        flex-direction: column;
        overflow: auto;
        padding: .25rem .75rem .25rem .75rem;
    }

    .chat-input {
        flex: 0 0 auto;
        padding: .35rem .5rem .5rem .5rem;
    }

    .chat-bubble-group {
        margin-bottom: .35rem;
    }

</style>

<MudPaper Class="chat-wrapper" Elevation="1">
    <div class="chat-header d-flex align-center">
        <MudText Typo="Typo.subtitle1" class="chat-header d-flex align-center">Assistant</MudText>
    </div>
    <MudDivider DividerType="DividerType.Middle" />

    <div class="chat-messages-host" @ref="_messagesHost">

        @foreach (var m in _messages) {
            <MudChat ChatPosition="@(m.IsSender? ChatBubblePosition.End: ChatBubblePosition.Start)" Class="chat-bubble-group">
                <MudChatBubble>@m.Content</MudChatBubble>
            </MudChat>
        }

    </div>
    <MudDivider DividerType="DividerType.Middle" />
    <div Class="chat-input">
        <MudTextField @bind-Value="_userInput"
                      Immediate="true"
                      Placeholder="Type a command..."
                      Lines="3"
                      Disabled="_sending"
                      Adornment="Adornment.End"
                      AdornmentIcon="@Icons.Material.Filled.Send"
                      AdornmentColor="@(_sending || string.IsNullOrWhiteSpace(_userInput) ? Color.Default : Color.Warning)"
                      OnAdornmentClick="@(async _ => await SendAsync())"
                      OnKeyUp="HandleKeyUp" />
    </div>
</MudPaper>

@code {
    public class MudChatMessage {
        public string? Content { get; set; }
        public bool IsSender { get; set; } = true; 
    }

    private string _userInput = "Chart with 5 top-performers";
    private bool _sending;

    private readonly List<MudChatMessage> _messages = new();
    // Conversation history for AsonClient (mirrors WPF ChatViewModel approach)
    private readonly List<ChatMessage> _conversation = new();
    private ElementReference _messagesHost;

    // Public API so other components (e.g., Home prompt cards) can trigger a send
    public async Task SendPromptAsync(string prompt) {
        if (string.IsNullOrWhiteSpace(prompt)) return;
        _userInput = prompt;
        await SendAsync();
    }

    private async Task SendAsync() {
        if (string.IsNullOrWhiteSpace(_userInput) || _sending) return;
        var userContent = _userInput.Trim();
        _userInput = string.Empty; // clear immediately
        _sending = true;

        var userMsg = new MudChatMessage { Content = userContent, IsSender = true };
        _messages.Add(userMsg);
        _conversation.Add(new ChatMessage(ChatRole.User, userContent));
        var assistantMsg = new MudChatMessage { Content = string.Empty, IsSender = false };
        _messages.Add(assistantMsg);
        await InvokeAsync(StateHasChanged);

        try {
            await foreach (var chunk in Client.SendStreamingAsync(_conversation)) {
                if (!string.IsNullOrEmpty(chunk)) {
                    assistantMsg.Content += chunk;
                    await InvokeAsync(StateHasChanged);
                }
            }
        }
        finally {
            // After streaming completes, persist assistant reply to conversation history
            if (!string.IsNullOrWhiteSpace(assistantMsg.Content)) {
                _conversation.Add(new ChatMessage(ChatRole.Assistant, assistantMsg.Content));
            }
            _sending = false;
            await InvokeAsync(StateHasChanged);
        }
    }

    private void HandleKeyUp(KeyboardEventArgs args) {
        if (args.Key == "Enter" && !args.ShiftKey) {
            if (_userInput.EndsWith("\n"))
                _userInput = _userInput.TrimEnd('\r', '\n');
            _ = SendAsync();
        }
    }
}
